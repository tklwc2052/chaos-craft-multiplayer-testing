<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Forklift Simulator V16</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background-color: #333; }
        
        /* LOGIN SCREEN */
        #login {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #1a1a1a, #2a2a2a);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; color: white;
        }
        input { padding: 10px; font-size: 16px; margin: 10px; border-radius: 5px; border: none; }
        button {
            padding: 10px 20px; font-size: 18px; cursor: pointer;
            background-color: #e6b800; border: none; border-radius: 5px; font-weight: bold;
        }
        button:hover { background-color: #ffcc00; }

        /* GAME UI */
        #ui {
            display: none; position: absolute; top: 10px; left: 10px;
            color: yellow; font-family: monospace; font-size: 14px;
            background: rgba(0, 0, 0, 0.5); padding: 10px; border-radius: 5px; pointer-events: none;
        }

        /* ERROR BOX (For debugging) */
        #debug-log {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 100px;
            background: rgba(0,0,0,0.8); color: red; font-family: monospace;
            overflow-y: scroll; display: none; padding: 5px; pointer-events: none;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="/socket.io/socket.io.js"></script> </head>
<body>

    <div id="login">
        <h1>FORKLIFT SIMULATOR V16</h1>
        <p>Stealth Spec â€¢ Sport Edition</p>
        <input type="text" id="usernameInput" placeholder="Enter Driver Name" autocomplete="off">
        <button id="startBtn">JOIN GAME</button>
        <p style="font-size: 12px; opacity: 0.7;">(Or press ENTER to start)</p>
        <div id="status-msg" style="margin-top:10px; color: #aaa;">Ready to connect...</div>
    </div>

    <div id="ui">
        DRIVER: <span id="userNameDisplay">Player</span><br>
        CONTROLS: W,A,S,D to Drive | R/F to Lift Forks | E to Exit Seat
    </div>

    <div id="debug-log"></div>

    <script>
        // --- 1. ROBUST ERROR LOGGING ---
        function logError(msg) {
            console.error(msg);
            const box = document.getElementById('debug-log');
            box.style.display = 'block';
            box.innerHTML += `> ${msg}<br>`;
        }
        window.onerror = function(msg) { logError("SYSTEM ERROR: " + msg); };

        // --- 2. SETUP VARIABLES ---
        let socket = null;
        let isOfflineMode = false;
        
        // --- 3. ATTEMPT CONNECTION ---
        try {
            if (typeof io !== 'undefined') {
                socket = io();
                document.getElementById('status-msg').innerText = "Server Found. Ready.";
            } else {
                throw new Error("Socket.io missing");
            }
        } catch (e) {
            console.warn("Server connection failed. switching to OFFLINE MODE.");
            isOfflineMode = true;
            document.getElementById('status-msg').innerText = "Server Blocked. Solo Mode Enabled.";
            // Mock Socket for Offline Play
            socket = {
                emit: function(ev, data) { }, // Do nothing
                on: function(ev, fn) { }      // Do nothing
            };
        }

        // --- 4. GAME ENGINE ---
        let scene, camera, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, isShifting = false;
        let forkMovingUp = false, forkMovingDown = false;
        let velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        
        // FORKLIFT PARTS
        let forklift = null, forksPart = null;
        let isDriving = false;

        // START GAME FUNCTION
        function startGame() {
            const name = document.getElementById('usernameInput').value || "Driver";
            document.getElementById('userNameDisplay').innerText = name;
            document.getElementById('login').style.display = 'none';
            document.getElementById('ui').style.display = 'block';

            init3D();
            
            if(!isOfflineMode) {
                socket.emit('join', { username: name });
            }
        }

        // BUTTON CLICK
        document.getElementById('startBtn').addEventListener('click', startGame);
        
        // ENTER KEY SUPPORT
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && document.getElementById('login').style.display !== 'none') {
                startGame();
            }
        });

        function init3D() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); 
            scene.fog = new THREE.Fog(0x87ceeb, 10, 80);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.rotation.order = 'YXZ';

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.outputEncoding = THREE.sRGBEncoding;
            document.body.appendChild(renderer.domElement);

            // CONTROLS FALLBACK
            if(typeof THREE.PointerLockControls !== 'undefined') {
                controls = new THREE.PointerLockControls(camera, document.body);
                document.addEventListener('click', () => { controls.lock(); });
            } else {
                alert("Missing PointerLockControls. Mouse capture disabled.");
                controls = { isLocked: true, getObject: () => camera, moveForward: (d)=>camera.translateZ(-d), moveRight: (d)=>camera.translateX(d) };
            }

            camera.position.set(5, 5, 10);
            camera.lookAt(0, 0, 0);

            // LIGHTING
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.1);
            dirLight.position.set(12, 20, 8);
            dirLight.castShadow = true;
            scene.add(dirLight);

            // GROUND
            const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({color: 0x333333, roughness: 0.8}));
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            scene.add(ground);

            buildForklift();

            // INPUTS
            const onKeyDown = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': if (!isDriving && !canJump) { velocity.y = 10; canJump = true; } break;
                    case 'KeyE': toggleDrive(); break;
                    case 'KeyR': forkMovingUp = true; break;
                    case 'KeyF': forkMovingDown = true; break;
                    case 'ShiftLeft': isShifting = true; break;
                }
            };
            const onKeyUp = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'KeyR': forkMovingUp = false; break;
                    case 'KeyF': forkMovingDown = false; break;
                    case 'ShiftLeft': isShifting = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);

            animate();
        }

        // --- THE V14 "SPORT EDITION" BUILDER ---
        function buildForklift() {
            forklift = new THREE.Group();
            
            const matBody = new THREE.MeshStandardMaterial({ color: 0xE6B800, roughness: 0.3, side: THREE.DoubleSide });
            const matDark = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
            const matIron = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });
            const matSteel = new THREE.MeshStandardMaterial({ color: 0xAAAAAA, roughness: 0.3 });
            const matCage = new THREE.MeshStandardMaterial({ color: 0x050505, roughness: 0.4 }); // Black Cage
            const matTank = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 0.4 });

            const chassis = new THREE.Group();

            // 1. REAR (Engine)
            const rear = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.8), matBody);
            rear.position.set(0, 0.85, 0.8); rear.castShadow = true; chassis.add(rear);

            // Counterweight
            const cw = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.9, 0.5), matBody); cw.position.set(0, 0.95, 1.35); chassis.add(cw);
            
            // 2. FRONT (Dash)
            const front = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.6, 0.5), matBody);
            front.position.set(0, 0.8, -0.6); front.castShadow = true; chassis.add(front);

            // 3. MIDDLE FLOOR
            const floor = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.1, 1.0), matBody);
            floor.position.set(0, 0.45, 0.1); chassis.add(floor);

            // 4. FENDERS
            // Front (Retracted)
            const arch = new THREE.CylinderGeometry(0.5, 0.5, 0.3, 32, 1, true, 0, Math.PI);
            const fFL = new THREE.Mesh(arch, matBody); fFL.rotation.z = Math.PI/2; fFL.position.set(-0.55, 0.4, -0.5); chassis.add(fFL);
            const fFR = new THREE.Mesh(arch, matBody); fFR.rotation.z = Math.PI/2; fFR.position.set(0.55, 0.4, -0.5); chassis.add(fFR);
            
            // Rear
            const boxF = new THREE.BoxGeometry(0.3, 0.1, 0.8);
            const fRL = new THREE.Mesh(boxF, matBody); fRL.position.set(-0.55, 0.7, 0.8); chassis.add(fRL);
            const fRR = new THREE.Mesh(boxF, matBody); fRR.position.set(0.55, 0.7, 0.8); chassis.add(fRR);

            // Connectors (Steps & Ramps)
            const stepG = new THREE.BoxGeometry(0.3, 0.05, 0.8);
            const sL = new THREE.Mesh(stepG, matBody); sL.position.set(-0.55, 0.4, -0.1); chassis.add(sL);
            const sR = new THREE.Mesh(stepG, matBody); sR.position.set(0.55, 0.4, -0.1); chassis.add(sR);
            
            const rampG = new THREE.BoxGeometry(0.3, 0.05, 0.55);
            const rL = new THREE.Mesh(rampG, matBody); rL.position.set(-0.55, 0.55, 0.45); rL.rotation.x = -0.6; chassis.add(rL);
            const rR = new THREE.Mesh(rampG, matBody); rR.position.set(0.55, 0.55, 0.45); rR.rotation.x = -0.6; chassis.add(rR);

            // 5. UNDERCARRIAGE
            const base = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.4, 2.0), matDark); base.position.set(0, 0.4, 0.3); chassis.add(base);
            forklift.add(chassis);

            // 6. TANK
            const tank = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.8, 16), matTank);
            tank.rotation.z = Math.PI/2; tank.position.set(0, 1.5, 1.2); forklift.add(tank);
            const strap = new THREE.Mesh(new THREE.CylinderGeometry(0.21, 0.21, 0.05, 16), matDark);
            const s1 = strap.clone(); s1.rotation.z = Math.PI/2; s1.position.set(-0.25, 1.5, 1.2); forklift.add(s1);
            const s2 = strap.clone(); s2.rotation.z = Math.PI/2; s2.position.set(0.25, 1.5, 1.2); forklift.add(s2);

            // 7. CAGE (Angled Black)
            const cage = new THREE.Group();
            const pipe = new THREE.CylinderGeometry(0.04, 0.04, 1.6, 12);
            // Front Angled
            const p1 = new THREE.Mesh(pipe, matCage); p1.position.set(-0.5, 1.8, -0.5); p1.rotation.x = 0.1; cage.add(p1);
            const p2 = new THREE.Mesh(pipe, matCage); p2.position.set(0.5, 1.8, -0.5); p2.rotation.x = 0.1; cage.add(p2);
            // Rear
            const p3 = new THREE.Mesh(pipe, matCage); p3.position.set(-0.5, 1.8, 1.0); p3.rotation.x = -0.1; cage.add(p3);
            const p4 = new THREE.Mesh(pipe, matCage); p4.position.set(0.5, 1.8, 1.0); p4.rotation.x = -0.1; cage.add(p4);
            // Roof
            const r1 = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.6, 12), matCage); r1.rotation.x=Math.PI/2; r1.position.set(-0.5, 2.6, 0.25); cage.add(r1);
            const r2 = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.04, 1.6, 12), matCage); r2.rotation.x=Math.PI/2; r2.position.set(0.5, 2.6, 0.25); cage.add(r2);
            // Slats
            for(let i=0; i<5; i++) {
                const s = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.02, 0.15), matCage);
                s.position.set(0, 2.62, -0.3 + (i*0.25)); s.rotation.x = 0.2; cage.add(s);
            }
            forklift.add(cage);

            // 8. INTERIOR & WHEELS
            const wh = new THREE.Mesh(new THREE.TorusGeometry(0.18, 0.03, 8, 16), matDark); wh.position.set(0, 1.7, -0.55); wh.rotation.x = 0.5; forklift.add(wh);
            
            const seat = new THREE.Group();
            seat.add(new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.15, 0.6), new THREE.MeshStandardMaterial({color:0x111111})));
            const sb = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 0.1), new THREE.MeshStandardMaterial({color:0x111111}));
            sb.position.set(0, 0.35, 0.3); sb.rotation.x = -0.15; seat.add(sb);
            seat.position.set(0, 1.25, 0.6); // Lowered
            forklift.add(seat);

            const wG = new THREE.CylinderGeometry(0.4, 0.4, 0.25, 24); wG.rotateZ(Math.PI/2);
            const w1 = new THREE.Mesh(wG, matDark); w1.position.set(-0.55, 0.4, -0.6); forklift.add(w1);
            const w2 = new THREE.Mesh(wG, matDark); w2.position.set(0.55, 0.4, -0.6); forklift.add(w2);
            const w3 = new THREE.Mesh(wG, matDark); w3.scale.set(0.7, 0.7, 0.7); w3.position.set(-0.55, 0.28, 0.8); forklift.add(w3);
            const w4 = new THREE.Mesh(wG, matDark); w4.scale.set(0.7, 0.7, 0.7); w4.position.set(0.55, 0.28, 0.8); forklift.add(w4);

            // 9. MAST & FORKS
            const mast = new THREE.Group();
            const rail = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.8, 0.15), matSteel);
            const rA = rail.clone(); rA.position.set(-0.35, 1.6, -0.9); mast.add(rA);
            const rB = rail.clone(); rB.position.set(0.35, 1.6, -0.9); mast.add(rB);
            const cr = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.15, 0.1), matDark); cr.position.set(0, 3.0, -0.9); mast.add(cr);
            forklift.add(mast);

            forksPart = new THREE.Group();
            const plate = new THREE.Mesh(new THREE.BoxGeometry(0.9, 0.5, 0.05), matIron); forksPart.add(plate);
            
            const tine = new THREE.BoxGeometry(0.12, 0.04, 1.3);
            const tL = new THREE.Mesh(tine, matIron); tL.position.set(-0.35, -0.3, -0.65); forksPart.add(tL);
            const hL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.04), matIron); hL.position.set(-0.35, 0, -0.02); forksPart.add(hL);
            
            const tR = new THREE.Mesh(tine, matIron); tR.position.set(0.35, -0.3, -0.65); forksPart.add(tR);
            const hR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.7, 0.04), matIron); hR.position.set(0.35, 0, -0.02); forksPart.add(hR);
            
            forksPart.position.set(0, 0.5, -1.0);
            forklift.add(forksPart);

            scene.add(forklift);
        }

        function toggleDrive() {
            if (isDriving) {
                isDriving = false;
                camera.position.x -= 2; camera.position.y = 1.6;
                if(!isOfflineMode) socket.emit('leave-seat');
            } else {
                if (forklift && camera.position.distanceTo(forklift.position) < 5.0) {
                    isDriving = true;
                    if(!isOfflineMode) socket.emit('request-drive');
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = 0.016;

            if (isDriving && forklift) {
                const speed = 10.0 * delta;
                const rotSpeed = 2.0 * delta;
                let moved = false;

                if (moveForward) { forklift.position.x += Math.sin(forklift.rotation.y)*speed; forklift.position.z += Math.cos(forklift.rotation.y)*speed; moved=true; }
                if (moveBackward) { forklift.position.x -= Math.sin(forklift.rotation.y)*speed; forklift.position.z -= Math.cos(forklift.rotation.y)*speed; moved=true; }
                if (moveLeft) { forklift.rotation.y -= rotSpeed; moved=true; }
                if (moveRight) { forklift.rotation.y += rotSpeed; moved=true; }

                if (forksPart) {
                    if (forkMovingUp && forksPart.position.y < 3.0) { forksPart.position.y += 0.05; moved=true; }
                    if (forkMovingDown && forksPart.position.y > 0.5) { forksPart.position.y -= 0.05; moved=true; }
                }

                camera.position.copy(forklift.position).add(new THREE.Vector3(0, 2.8, 0)); // Driver Eye view
                
                if (moved && !isOfflineMode) {
                    socket.emit('move-forklift', {
                        x: forklift.position.x, z: forklift.position.z, ry: forklift.rotation.y,
                        forkHeight: forksPart ? forksPart.position.y - 0.5 : 0
                    });
                }
            } else if (controls.isLocked) {
                velocity.x -= velocity.x * 10.0 * delta;
                velocity.z -= velocity.z * 10.0 * delta;
                velocity.y -= GRAVITY * delta;
                
                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 400.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 400.0 * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);
                camera.position.y += (velocity.y * delta);

                if (camera.position.y < 1.6) { velocity.y = 0; camera.position.y = 1.6; canJump = false; }
            }
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>
